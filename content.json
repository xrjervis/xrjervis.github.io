{"meta":{"title":"Rui \"Siri\" Xie","subtitle":"Siri | Gameplay Programmer","description":"Portfolio Site","author":"Rui Xie","url":"http://ruixie.site"},"pages":[{"title":"","date":"2018-07-20T06:44:57.727Z","updated":"2018-07-20T06:44:57.727Z","comments":true,"path":"pages/about.html","permalink":"http://ruixie.site/pages/about.html","excerpt":"","text":"Favorite Games: Divinity: Original Sin II Legend of Zelda: Breath of the Wild Persona 5 The Witcher 3: Wild Hunt Rimworld FIFA Series About Me Gameplay Programmer, hard worker, and RPG enthusiast Hi! My name is Rui Xie, but I prefer to go by Siri. Currently I am studying at SMU Guildhall, majoring in Digital Game Development with a specialization in programming track. Dating back to senior high school, the emergence of giant game producers such as Nintendo, Sony and Blizzard highlighted the growth of gaming business. Realizing the crucial knowledge of both the software and hardware of game platforms as well as general programming skills for an excellent game developer, I chose to major in Computer Science and Technology during my undergraduate study To further pursue my burning desire to challenge myself and make games, I also participated and awarded in contests such as the ABU Asia-Pacific Robot Contest (a.k.a. Robocon) and the 2016 Microsoft Imagine Cup, where I had my first taste of VR development. Additionally, I aspire to explore new things and object to blindly following the crowd. With my innovative and courageous spirit, I keep pace with new features of architecture frameworks published on the official website and I lead my class in employing these new features when carrying out new projects."},{"title":"","date":"2018-07-20T06:04:49.592Z","updated":"2018-07-20T06:04:49.592Z","comments":true,"path":"pages/resume.html","permalink":"http://ruixie.site/pages/resume.html","excerpt":"","text":""}],"posts":[{"title":"Interstellar Racing League","slug":"UE4_InerstellarRacingLeague","date":"2018-07-19T22:55:23.000Z","updated":"2018-07-20T21:16:36.230Z","comments":true,"path":"2018/07/19/UE4_InerstellarRacingLeague/","link":"","permalink":"http://ruixie.site/2018/07/19/UE4_InerstellarRacingLeague/","excerpt":"","text":"Interstellar Racing League is a high-speed, 4 player racing experience. Players are racing along gravity-defying tracks through alien planets to compete for the title of the Galaxy’s Best Racer. Overview Role: Physics Programmer Engine: Unreal Engine 4.17 Genre: Arcade Racing Dev Time: 4 months Team Size: 56 (15 programmers) Download: PC(Windows) Game Trailer Physics ModelFirst ApproachThe first version of the physics model was inspired by a tutorial video created by Space Dust Racing UE4 Arcade Vehicle Physics Tour, in which it introduced the implementation of a basic 4-point hover car physics. In this approach, we: Disable the built-in gravity, and always apply a force downwards to the ground to make the car running on the multi-axis track Put 4 hover force components at each corner of the bottom of the car and added forces upwards, to make the car float to simulate the hovering feel Set linear damping to 0 and use customized 3-axis linear damping Move the center of mass (COM) of the car below the actual model to make the car behave like a tumbler such that prevents the car from flipping over However, the tutorial only covers the basics of the physics, and created issues when the track became complicated. Also, many of the gameplay features we planned for the model were still missing. Our team decided to modify the physics model to meet the needs of our game. Upgraded to 1P1F Physics Model1P1F refers to 1-Point-1-Force. The benefit of using a single point model is that it provides a very intuitive way for us to understand how different forces influence the car. As you might know from the physics class, the easiest way to analyze the resultant force on one object is to destruct them on its COM. Also, we refactored the vehicle blueprint to a component-based architecture, including the suspension component, the stability component, the collision component and input control component. Surface Detection Phase Raycast downward to the track, and stores the hit result for later use. If raycast hits the track, also stores it as the last result Raycast forward in a certain distance to predict any sudden rise of the track Physics Simulation PhaseSuspension Component Use the equation shown below to caculate up and down force X-axis represents the hover height, and the intersection point is the height we want the vehicle to be stable at. Y-axis represents the up force value we apply to the vehicle. Also we clamp the value to prevent applying an infinite larget force when x-&gt;0 and x-&gt;∞. Stability Component Calculate the falldown force according to the steepness of the track that the vehicle is driving on Calculate the air drag force acoording to vehicle’s velocity in X, Y and Z axis According to the hit result we stored in surface detection phase, set current alignment vector and calculate how much torque needed to rotate the vehicle to make it align to the track InputControl Component Calculate vehicle’s horizontal linear force when player presses acclerate and brake buttons By the end of tick function, add forces and torques together and apply to the model’s COM. Gallery","categories":[{"name":"Team Projects","slug":"Team-Projects","permalink":"http://ruixie.site/categories/Team-Projects/"},{"name":"Unreal Engine 4","slug":"Team-Projects/Unreal-Engine-4","permalink":"http://ruixie.site/categories/Team-Projects/Unreal-Engine-4/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"http://ruixie.site/tags/UE4/"}]},{"title":"Feline Friendship Force","slug":"Unity_FelineFriendshipForce","date":"2018-07-18T22:55:23.000Z","updated":"2018-07-20T04:42:52.180Z","comments":true,"path":"2018/07/18/Unity_FelineFriendshipForce/","link":"","permalink":"http://ruixie.site/2018/07/18/Unity_FelineFriendshipForce/","excerpt":"","text":"Feline Friendship Force (FFF) is a 2D turn-based puzzle game with 12 levels where the player guides cats using a laser pointer to rejoice in the power of friendship. Overview Role: Gameplay Programmer Engine: Unity 2017.1 Genre: Turn-based puzzle Dev Time: 11 Weeks Team Size: 5 (2 programmers) Download: PC(Windows) Android APK Responsibility Created node editor for level designers Worked with artist to integrate sprite animation with character movement Worked on UI interaction Implemented Enemy AI state machine and transition Polished the rewarding win screen with better visual effects Implemented box and water gameplay mechanics Implemented level progress data saving and loading system Gameplay FeaturesMovementAll the movement of the characters is controlled by player input. At the beginning of the game, GameController starts to listen to all events like OnNodeDown, OnNodeUp, and OnNodeDragHit. In MouseController script, the program detects player’s input every frame. Whenever player triggers an event, MouseController informs GameController through the EventManager to call the corresponding method. NodeConnection indicates how nodes connect with each other. Players can re-pick the node when they keep pressing on the screen and can only move to the adjacent node. BoxBox element can hide cats from dogs. When the player moves the cat into a box, the cat disappears along with a green outline shader showing on the box, indicating that player can move the cat outside the box as well. Dogs cannot see the cat inside the box, but they can move through the node with a box on it still. WaterWater is an obstacle which blocks the movement of both cats and dogs. Dogs cannot even see through the water. There is a pressure plate on another node which controls the water. Whenever there’s an object standing on it, no matter a cat or a dog, the water is off, which means the obstacle is gone. Enemy AIEnemy AI conveyance is clear. Dogs can see through nodes connected in a straight line unless there are any obstacles. If the dog sees a cat, it turns to chase mode. If the dog cannot see a cat anymore, it turns to still mode with a question mark on its head. Achievement SystemWhen both cats are on the same node the win screen shows the player what achievements they earned. And the data will be saved locally so that players can restart the level and change their strategy to get extra items or find the shortest path to beat the level.","categories":[{"name":"Team Projects","slug":"Team-Projects","permalink":"http://ruixie.site/categories/Team-Projects/"},{"name":"Unity","slug":"Team-Projects/Unity","permalink":"http://ruixie.site/categories/Team-Projects/Unity/"}],"tags":[{"name":"UNITY","slug":"UNITY","permalink":"http://ruixie.site/tags/UNITY/"}]},{"title":"RayX Engine","slug":"Personal_RayXEngine","date":"2018-07-17T22:55:23.000Z","updated":"2018-07-19T19:53:09.368Z","comments":true,"path":"2018/07/17/Personal_RayXEngine/","link":"","permalink":"http://ruixie.site/2018/07/17/Personal_RayXEngine/","excerpt":"","text":"","categories":[{"name":"Indiviual Projects","slug":"Indiviual-Projects","permalink":"http://ruixie.site/categories/Indiviual-Projects/"},{"name":"Personal Engine","slug":"Indiviual-Projects/Personal-Engine","permalink":"http://ruixie.site/categories/Indiviual-Projects/Personal-Engine/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://ruixie.site/tags/C/"}]},{"title":"Data-Driven GameBuilder 2D","slug":"DFS_GameBuilder","date":"2018-07-16T22:55:23.000Z","updated":"2018-07-20T19:27:54.552Z","comments":true,"path":"2018/07/16/DFS_GameBuilder/","link":"","permalink":"http://ruixie.site/2018/07/16/DFS_GameBuilder/","excerpt":"","text":"A 2D data-driven game builder that can be used to author many 2D game types easily from XML data files. Overview Engine: Personal Engine Languages: C++, XML Dev Time: 8 weeks Code Repo: Github Property TreeHere is an example of an EntityDefinition XML node:12345678910111213141516171819202122232425262728&lt;EntityDefinition name=\"PlayerTank\" spriteSheet=\"PlayerTank_1x1\" spriteCoords=\"0,0\" tags=\"canWalk,friend,player\" collider=\"Disc2\" size=\"1.5,1.5\" health=\"10\" speed=\"2\"&gt; &lt;Event type=\"MoveUp\"&gt; &lt;Command name=\"AddMovement\" value=\"0.0,1.0\"/&gt; &lt;/Event&gt; &lt;Event type=\"MoveDown\"&gt; &lt;Command name=\"AddMovement\" value=\"0.0,-1.0\"/&gt; &lt;/Event&gt; &lt;Event type=\"MoveLeft\"&gt; &lt;Command name=\"AddMovement\" value=\"-1.0,0.0\"/&gt; &lt;/Event&gt; &lt;Event type=\"MoveRight\"&gt; &lt;Command name=\"AddMovement\" value=\"1.0,0.0\"/&gt; &lt;/Event&gt; &lt;Event type=\"Shoot\"&gt; &lt;Command name=\"SpawnEntity\" target=\"self\" value=\"PlayerBullet\"/&gt; &lt;/Event&gt; &lt;Event type=\"Jump\"&gt; &lt;Command name=\"SetVelocity\" value=\"0.0,5.0\" setTimer=\"2.0\"/&gt; &lt;/Event&gt;&lt;/EntityDefinition&gt; Generate, copy, delete recursively, no memory leaks! 12345678910111213141516171819// PropertySet membersStringId m_id;std::vector&lt;Property&gt; m_properties;std::vector&lt;std::unique_ptr&lt;PropertySet&gt;&gt; m_children;// ConstructorPropertySet::PropertySet(const pugi::xml_node&amp; xmlNode) &#123; m_id = CreateOrGetStringId(std::string(xmlNode.name())); for (pugi::xml_attribute attribute : xmlNode.attributes()) &#123; SetProperty(attribute.name(), attribute.as_string()); &#125; size_t nodeCount = std::distance(xmlNode.children().begin(), xmlNode.children().end()); if (nodeCount &gt; 0) &#123; for (pugi::xml_node child : xmlNode.children()) &#123; AddChild(child); &#125; &#125;&#125; EntityDefinition loads data from XML. When we create an entity, it holds a copy 12345678// Copy ConstructorPropertySet::PropertySet(const PropertySet&amp; copy) &#123; m_id = copy.m_id; m_properties = copy.m_properties; for (auto&amp; it : copy.m_children) &#123; m_children.emplace_back(std::make_unique&lt;PropertySet&gt;(*it)); &#125;&#125; Property object holds the value as a string which can be parsed to the type I want 12345678910111213141516171819202122232425262728class Property &#123;public: Property() = default; Property(const std::string&amp; name, const std::string&amp; val); ~Property() = default; std::string GetName() const; StringI GetID() const; bool IsValid() const; bool AsBool() const; float AsFloat() const; int AsInt() const; Vector2 AsVec2() const; IntVector2 AsIntVec2() const; Rgba AsRgba() const; Tags AsTags() const; std::string AsString() const; const char* AsRawString() const; eEventType AsEventType() const; void SetValue(const std::string&amp; val);private: StringId m_id; std::string m_value; bool m_isVaild = false;&#125;; How does the GameBuilder work with data? When the game starts Load 3 definition files: EntityDefinition, MapDefinition, TileDefinition Load GameConfig file which contains global data, resource path and input mapping 12345678910111213141516171819202122232425262728&lt;GameConfig cameraHeight=\"12.0\" cameraAspect=\"1.7778\" cameraClamp=\"true\" cameraFollowPlayers=\"false\" gravity=\"0.0,0.0\" startMap=\"Dungeon\"&gt; &lt;Resources&gt; &lt;SpriteSheet name=\"Bat_8x6\" filePath=\"Data/Images/Bat_8x6.png\" layout=\"8,6\"/&gt; &lt;SpriteSheet name=\"Terrain_32x32\" filePath=\"Data/Images/Terrain_32x32.png\" layout=\"32,32\"/&gt; &lt;SpriteSheet name=\"PlayerTank_1x1\" filePath=\"Data/Images/PlayerTank_1x1.png\" layout=\"1,1\"/&gt; &lt;SpriteSheet name=\"EnemyTank_1x1\" filePath=\"Data/Images/EnemyTank_1x1.png\" layout=\"1,1\"/&gt; &lt;SpriteSheet name=\"Characters_12x53\" filePath=\"Data/Images/KushnariovaCharacters_12x53.png\" layout=\"12,53\"/&gt; &lt;SpriteSheet name=\"Bullet_1x1\" filePath=\"Data/Images/Bullet_1x1.png\" layout=\"1,1\"/&gt; &lt;/Resources&gt; &lt;Input&gt; &lt;OnKeyDown key=\"W\" event=\"MoveUp\"/&gt; &lt;OnKeyDown key=\"S\" event=\"MoveDown\"/&gt; &lt;OnKeyDown key=\"A\" event=\"MoveLeft\"/&gt; &lt;OnKeyDown key=\"D\" event=\"MoveRight\"/&gt; &lt;OnKeyPressed key=\"Space\" event=\"Shoot\"/&gt; &lt;OnKeyDown key=\"I\" event=\"MoveUp2\"/&gt; &lt;OnKeyDown key=\"K\" event=\"MoveDown2\"/&gt; &lt;OnKeyDown key=\"J\" event=\"MoveLeft2\"/&gt; &lt;OnKeyDown key=\"L\" event=\"MoveRight2\"/&gt; &lt;OnKeyPressed key=\"Enter\" event=\"Shoot2\"/&gt; &lt;/Input&gt;&lt;/GameConfig&gt; Runtime Map Reload NOT a full reload Just overrides data (definitions &amp; game config) Event System Support events OnOverlapBegin OnOverlapStay OnOverlapEnd OnHit Died Custom Event (Defined in Data) Compare entity pairs of last frame and this frame seperate OnHit and OnOverlap events 12345678910111213141516171819202122232425262728293031323334void ProtoState::CompareEntityPairList() &#123; PROFILE_SCOPE_FUNTION(); for (auto&amp; it : m_hitCurrentFramePairs) &#123; if (std::find(m_hitLastFramePairs.begin(), m_hitLastFramePairs.end(), it) == m_hitLastFramePairs.end()) &#123; // trigger OnHit event g_theEventSystem.Trigger(\"OnHit\", it.first, it.second); &#125; &#125; for (auto&amp; currentIt : m_overlapCurrentFramePairs) &#123; if (std::find(m_overlapLastFramePairs.begin(), m_overlapLastFramePairs.end(), currentIt) == m_overlapLastFramePairs.end()) &#123; // trigger OnOverlapBegin event g_theEventSystem.Trigger(\"OnOverlapBegin\", currentIt.first, currentIt.second); &#125; else &#123; // trigger OnOverlapStay event g_theEventSystem.Trigger(\"OnOverlapStay\", currentIt.first, currentIt.second); &#125; &#125; for (auto&amp; lastIt : m_overlapLastFramePairs) &#123; if (std::find(m_overlapCurrentFramePairs.begin(), m_overlapCurrentFramePairs.end(), lastIt) == m_overlapCurrentFramePairs.end()) &#123; // trigger OnOverlapEnd event g_theEventSystem.Trigger(\"OnOverlapEnd\", lastIt.first, lastIt.second); &#125; &#125; m_overlapLastFramePairs = m_overlapCurrentFramePairs; m_hitLastFramePairs = m_hitCurrentFramePairs; m_overlapCurrentFramePairs.clear(); m_hitCurrentFramePairs.clear();&#125; Overload Triggers Trigger events on entity pairs &lt;self, other&gt; Trigger events on certain entity Trigger events on all entities (broadcast) Command System String-based, takes the Command PropertySet as input 1void Execute(PropertySet* commandNode, Entity* self, Entity* other = nullptr); Support commands AddMovement Destroy Damage SetOrientation SpawnEntity Gameplay MinutePost-Mortem Soft Takeaways Trello for task schedule Debugging is HARD! Spent 80% of time debugging! No debug system to visualize entities’ current stats Thanks to Git Hard Takeaways The way to organize entities: pointer vs. scoped object Design around the data, ie. Property Tree Modern C++ skills got practiced such as smart pointers, move semantics, RAII, RTTI, variadic templates, rvalue references, deeper understanding of how std library containers work","categories":[{"name":"Indiviual Projects","slug":"Indiviual-Projects","permalink":"http://ruixie.site/categories/Indiviual-Projects/"},{"name":"Personal Engine","slug":"Indiviual-Projects/Personal-Engine","permalink":"http://ruixie.site/categories/Indiviual-Projects/Personal-Engine/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://ruixie.site/tags/C/"}]}]}